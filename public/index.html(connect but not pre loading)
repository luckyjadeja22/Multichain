<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live Blockchain Speed Reveal</title>
    <style>
        body { background-color: #050505; color: #fff; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; display: flex; flex-direction: column; align-items: center; padding: 20px; margin: 0; }
        .header { text-align: center; margin-bottom: 30px; width: 100%; border-bottom: 1px solid #222; padding-bottom: 20px; }
        .grid-container { display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; width: 95vw; max-width: 1200px; }
        .grid-item { background: #111; border: 1px solid #333; position: relative; display: flex; flex-direction: column; overflow: hidden; border-radius: 8px; }
        .label { background: rgba(0, 0, 0, 0.9); padding: 10px; border-bottom: 1px solid #444; }
        .chain-name { color: #00ff88; font-weight: bold; text-transform: uppercase; font-size: 14px; display: block; margin-bottom: 5px; }
        .stat-row { display: flex; justify-content: space-between; font-size: 11px; color: #aaa; font-family: monospace; }
        .val { color: #fff; }
        canvas { width: 100%; aspect-ratio: 1/1; background: #000; image-rendering: pixelated; }
        .controls { margin-top: 30px; display: flex; gap: 15px; }
        button { background: #00ff88; color: #000; border: none; padding: 15px 45px; font-size: 16px; font-weight: 800; border-radius: 5px; cursor: pointer; transition: 0.3s; }
        button:hover { background: #fff; box-shadow: 0 0 20px #00ff88; }
        input[type="file"] { background: #222; color: #fff; padding: 10px; border-radius: 5px; border: 1px solid #444; }
    </style>
</head>
<body>

    <div class="header">
        <h1>Live Blockchain Pulse</h1>
        <p>Revealing pixels based on real-time Block Speed.</p>
        <input type="file" id="imageInput" accept="image/*">
    </div>

    <div class="grid-container" id="gridContainer"></div>

    <div class="controls">
        <button id="startBtn">SYNC & START</button>
    </div>

    <script>
        const config = [
            { name: "Fogo", endpoint: "/api/fogo-stats", img: "fogo.png" },
            { name: "Aptos", endpoint: "/api/aptos-stats", img: "aptos.png" },
            { name: "Sui", endpoint: "/api/sui-stats", img: "sui.png" },
            { name: "Solana", endpoint: "/api/solana-stats", img: "solana.png" },
            { name: "Op BNB", endpoint: "/api/bnb-stats", img: "opbnb.png" },
            { name: "Sei", endpoint: "/api/sei-stats", img: "sei.png" },
            { name: "Monad", endpoint: "/api/monad-stats", img: "monad.png" },
            { name: "Somnia", endpoint: "/api/somnia-stats", img: "somnia.png" },
            { name: "Arbitrum", endpoint: "/api/arbitrum-stats", img: "arbitrum.png" }
        ];

        let chainStates = {}; 

        async function updateChainData(item) {
            try {
                const res = await fetch(item.endpoint);
                const data = await res.json();
                
                const state = chainStates[item.name];
                const currentHeight = data.height || data.tx_count || 0;
                
                // Calculate Block Speed (time per block)
                let blockSpeed = "Calculating...";
                if (state.lastHeight > 0 && currentHeight > state.lastHeight) {
                    const blocksPassed = currentHeight - state.lastHeight;
                    const timePassed = Date.now() - state.lastUpdate;
                    const msPerBlock = timePassed / blocksPassed;
                    
                    blockSpeed = (msPerBlock / 1000).toFixed(2) + "s";
                    // Map Block Speed to animation delay: Faster blocks = lower delay
                    // We cap it between 1ms and 100ms for visual sanity
                    state.animDelay = Math.max(1, Math.min(100, msPerBlock / 50)); 
                }

                state.lastHeight = currentHeight;
                state.lastUpdate = Date.now();
                state.tps = data.tps ? data.tps.toFixed(2) : "0.00";

                // Update UI Labels live
                document.getElementById(`tps-${item.name}`).innerText = state.tps;
                document.getElementById(`speed-${item.name}`).innerText = blockSpeed;

            } catch (e) { console.error(`Error polling ${item.name}:`, e); }
        }

        function setupGrid(userImg) {
            const container = document.getElementById('gridContainer');
            container.innerHTML = '';
            
            config.forEach(item => {
                chainStates[item.name] = { lastHeight: 0, lastUpdate: Date.now(), animDelay: 50, tps: "0.00", isRunning: false };
                
                const div = document.createElement('div');
                div.className = 'grid-item';
                div.innerHTML = `
                    <div class="label">
                        <span class="chain-name">${item.name}</span>
                        <div class="stat-row">
                            <span>BLOCK SPEED: <span id="speed-${item.name}" class="val">---</span></span>
                            <span>TPS: <span id="tps-${item.name}" class="val">---</span></span>
                        </div>
                    </div>
                    <canvas id="canv-${item.name}"></canvas>
                `;
                container.appendChild(div);

                const canvas = div.querySelector('canvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();
                img.src = userImg ? userImg.src : item.img;
                img.onload = () => {
                    canvas.width = 400; canvas.height = 400;
                    ctx.drawImage(img, 0, 0, 400, 400);
                    const imgData = ctx.getImageData(0, 0, 400, 400);
                    ctx.fillStyle = "black";
                    ctx.fillRect(0, 0, 400, 400);
                    
                    chainStates[item.name].ctx = ctx;
                    chainStates[item.name].imgData = imgData;
                };
            });
        }

        document.getElementById('startBtn').addEventListener('click', () => {
            config.forEach(item => {
                const state = chainStates[item.name];
                if (state.isRunning) return;
                state.isRunning = true;

                // Start Polling every 1.5 seconds for live data
                setInterval(() => updateChainData(item), 1500);
                
                // Pixel setup
                let pixels = [];
                for (let i = 0; i < 400 * 400; i++) pixels.push(i);
                for (let i = pixels.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [pixels[i], pixels[j]] = [pixels[j], pixels[i]];
                }

                let currentIdx = 0;
                const clusterSize = 250; 

                function step() {
                    if (currentIdx < pixels.length) {
                        for (let n = 0; n < clusterSize; n++) {
                            const pPos = pixels[currentIdx + n];
                            if (!pPos) break;
                            const x = pPos % 400;
                            const y = Math.floor(pPos / 400);
                            const rIdx = pPos * 4;
                            const d = state.imgData.data;
                            state.ctx.fillStyle = `rgb(${d[rIdx]}, ${d[rIdx+1]}, ${d[rIdx+2]})`;
                            state.ctx.fillRect(x, y, 1, 1);
                        }
                        currentIdx += clusterSize;
                        // Use the LIVE fluctuating delay from the chain state
                        setTimeout(step, state.animDelay);
                    }
                }
                step();
            });
        });

        imageInput.addEventListener('change', (e) => {
            const reader = new FileReader();
            reader.onload = (ev) => {
                const img = new Image();
                img.onload = () => setupGrid(img);
                img.src = ev.target.result;
            };
            reader.readAsDataURL(e.target.files[0]);
        });

        window.onload = () => setupGrid(null);
    </script>
</body>
</html>